import fs from 'node:fs/promises';
import fsSync from 'node:fs';
import path from 'node:path';

function log(msg) {
  console.log(`[prepare-wrangler] ${msg}`);
}

async function fileExists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

function loadDevVarsIntoEnv(devVarsPath) {
  try {
    const raw = fsSync.readFileSync(devVarsPath, 'utf8');
    for (const line of raw.split(/\r?\n/)) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      const eq = trimmed.indexOf('=');
      if (eq === -1) continue;
      const key = trimmed.slice(0, eq).trim();
      const value = trimmed.slice(eq + 1).trim();
      if (!process.env[key]) {
        process.env[key] = value;
      }
    }
    log(`Loaded .dev.vars from ${devVarsPath}`);
  } catch (e) {
    log(`No .dev.vars loaded (${e.message})`);
  }
}

function injectIdsIntoKvBlock(kvBlock, envResolver) {
  // Extract inline tables like { binding = "X", ... }
  const tables = [...kvBlock.matchAll(/\{[^}]*\}/g)].map(m => m[0]);
  const updatedTables = [];
  for (const tbl of tables) {
    const bindingMatch = tbl.match(/binding\s*=\s*"([^"]+)"/);
    if (!bindingMatch) {
      updatedTables.push(tbl);
      continue;
    }
    const binding = bindingMatch[1];
    const envKeys = [
      `${binding}_ID`,
      `${binding}_KV_ID`,
      `${binding}_NAMESPACE_ID`,
    ];
    let idVal;
    for (const k of envKeys) {
      if (process.env[k]) { idVal = process.env[k]; break; }
    }
    // Special-case fallback for GEMINI_CLI_KV
    if (!idVal && binding === 'GEMINI_CLI_KV' && process.env.GEMINI_CLI_KV_ID) {
      idVal = process.env.GEMINI_CLI_KV_ID;
    }
    if (!idVal && typeof envResolver === 'function') {
      idVal = envResolver(binding);
    }
    if (!idVal) {
      log(`WARN: No ID found for KV binding '${binding}'. Leaving it unchanged.`);
      updatedTables.push(tbl);
      continue;
    }
    let newTbl;
    if (/(^|,)\s*id\s*=\s*"[^"]*"/.test(tbl)) {
      newTbl = tbl.replace(/id\s*=\s*"[^"]*"/, `id = "${idVal}"`);
    } else {
      newTbl = tbl.replace(/binding\s*=\s*"[^"]*"/, (m) => `${m}, id = "${idVal}"`);
    }
    updatedTables.push(newTbl);
  }
  // Reconstruct the kv block with updated tables, preserving outer wrapper
  // Replace the old tables in-order within the block
  let idx = 0;
  const rebuilt = kvBlock.replace(/\{[^}]*\}/g, () => updatedTables[idx++]);
  return rebuilt;
}

async function main() {
  const root = process.cwd();
  const basePath = path.join(root, 'wrangler.toml');
  const outPath = path.join(root, '.wrangler.generated.toml');
  const devVarsPath = path.join(root, '.dev.vars');

  if (!(await fileExists(basePath))) {
    console.error('wrangler.toml not found. Abort.');
    process.exit(1);
  }

  // Load .dev.vars to env as fallback (local dev)
  if (await fileExists(devVarsPath)) {
    loadDevVarsIntoEnv(devVarsPath);
  }

  let base = await fs.readFile(basePath, 'utf8');
  const kvRegex = /(^|\n)kv_namespaces\s*=\s*\[[\s\S]*?\]/m;
  const match = base.match(kvRegex);
  let updated = base;
  if (match) {
    const kvBlock = match[0];
    const newBlock = injectIdsIntoKvBlock(kvBlock, undefined);
    updated = base.replace(kvRegex, newBlock);
  } else {
    log('No kv_namespaces block found in wrangler.toml');
  }

  const header = '# THIS FILE IS AUTO-GENERATED. DO NOT COMMIT.\n# Generated by scripts/prepare-wrangler-config.mjs\n\n';
  await fs.writeFile(outPath, header + updated, 'utf8');
  log(`Wrote ${path.relative(root, outPath)}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
